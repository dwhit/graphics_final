#include "particlewidget.h"
#include "common.h"
#include "particleemitter.h"


#ifdef __APPLE__
#include <OpenGL/glu.h>
#else
#include <GL/glu.h>
#endif

#include "glm/gtc/matrix_transform.hpp"

#include "cs123_lib/resourceloader.h"

#include <QMouseEvent>
#include <QTimer>
#include <QGLShader>
#include <QGLShaderProgram>
#include <QFile>


ParticleWidget::ParticleWidget(QWidget *parent) : QGLWidget(QGLFormat(QGL::SampleBuffers | QGL::DoubleBuffer), parent)
{
    m_camera = new Camera();
    m_camera->eye.x = 0.0f, m_camera->eye.y = 0.0f, m_camera->eye.z = 50.0f;
    m_camera->center.x = 0.0f, m_camera->center.y = 0.0f, m_camera->center.z = -1.0f;
    m_camera->up.x = 0.0f, m_camera->up.y = 1.0f, m_camera->up.z = 0.0f;
    m_camera->angle = 45.0f, m_camera->near = .1f, m_camera->far = 1000.0f;

    //Do not change below here
    setAutoBufferSwap(false);
    setFocusPolicy(Qt::StrongFocus);
    m_timer = new QTimer(this);
    connect(m_timer, SIGNAL(timeout()), this, SLOT(redraw()));
    m_timer->start(1000.0f / 20.0f);
}

ParticleWidget::~ParticleWidget()
{
    SAFE_DELETE(m_timer);
    SAFE_DELETE(m_camera);
    SAFE_DELETE(m_emitter);
    makeCurrent();
}

/**
  * You need to fill this in.
  *
  * Loads the image at the given path and copies its data into an OpenGL texture.
  * @return The unique ID of the texture generated by this function.
  */
GLuint ParticleWidget::loadTexture(const QString &path)
{
    QImage texture;
    QFile file(path);
    if(!file.exists()) return -1;
    texture.load(file.fileName());
    texture = QGLWidget::convertToGLFormat(texture);

    // Put your code here
    glGenTextures(1, &m_textureId);
    glBindTexture(GL_TEXTURE_2D, m_textureId);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texture.width(),texture.height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, texture.bits());
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glBindTexture(GL_TEXTURE_2D, 0);

    return m_textureId; // Return something meaningful
}

/**
  * You need to fill this in.
  *
  * Called when this object is first created, to set the initial OpenGL state
  * required by this lab. Specify your render settings here.
  */
void ParticleWidget::initializeGL()
{
    GLenum err = glewInit();
    if (GLEW_OK != err)
    {
      /* Problem: glewInit failed, something is seriously wrong. */
      fprintf(stderr, "Error: %s\n", glewGetErrorString(err));
    }
    fprintf(stdout, "Status: Using GLEW %s\n", glewGetString(GLEW_VERSION));


    glClearColor(0.0f,0.0f,0.0f,0.0f);
    m_shader = ResourceLoader::loadShaders(":/shaders/shader.vert", ":/shaders/shader.frag");
    m_textureId = loadTexture(":/textures/particle2.bmp");
    m_emitter = new ParticleEmitter();
    m_emitter->initGL(glGetAttribLocation(m_shader, "position"), glGetAttribLocation(m_shader, "texCoord"));

    // Gl commands specific for this particle assignment
    glDisable(GL_DITHER);
    glDisable(GL_LIGHTING);


    updateCamera();
    emit _glInit(); //leave this
}

/**
  * You need to fill this in
  *
  * Called several times per second to draw your particlescene. This is where
  * all of your OpenGL render calls should occur.
  */
void ParticleWidget::paintGL()
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear the color & depth buffers.
    glActiveTexture(GL_TEXTURE0); // Set the active texture to texture 0.
    glUniform1i(glGetUniformLocation(m_shader,"textureSampler"), 0); // Tell the shader to use texture 0.

    m_emitter->updateParticles();       // Move the particles.


    glUseProgram(m_shader);

    // @TODO: Bind the texture before drawing the particles.
    glBindTexture(GL_TEXTURE_2D, m_textureId);

    m_emitter->drawParticlesVAO(m_transforms, glGetUniformLocation(m_shader, "mvp"), glGetUniformLocation(m_shader, "color"));
    glUseProgram(0);

    // @TODO: Unbind the texture and adjust the accumulation buffer.
    glBindTexture(GL_TEXTURE0, 0);

    glFlush();
    swapBuffers();
}

/**
  * Resizes the viewport so the scene doesn't look distorted when the window is resized.
  * You should not need to modify this.
  */
void ParticleWidget::resizeGL(int w, int h)
{
    glViewport(0, 0, w, h);
    updateCamera();
}

/**
  * Applied the current camera position and orientation to the OpenGL modelview and projection matrices.
  * You should not need to modify this.
  */
void ParticleWidget::updateCamera()
{
    float w = width(), h = height();
    float ratio = w / h;

    // Reset the coordinate system before modifying
    m_transforms.projection = glm::perspective(m_camera->angle, ratio, m_camera->near, m_camera->far);
    m_transforms.view = glm::lookAt(m_camera->eye, m_camera->center, m_camera->up);
}

void ParticleWidget::redraw() { repaint(); }
